{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Invoke-Tasks Documentation","text":"<p>Welcome to the documentation of the <code>Invoke-Tasks</code> tool. Please check the user guide on the left side for details or search for a topic.</p> <p>Here's   the feature list:</p> <ul> <li>Pure Powershell with a single script and no module/assembly dependency</li> <li>Running tasks in defined order</li> <li>Each task can have one dependency that runs first</li> <li>Capturing multiple output by defining named regexes written into a <code>captured.json</code></li> <li>Tasks can be tagged allowing to filter for tasks</li> <li>Tasks can be skipped</li> <li>It's possible to define task libraries (file as well as folder)</li> <li>Scripts are checked to use API functions only.</li> <li>Invoke-Tasks output can be hidden</li> <li>Task data (hashtable) can be shared accross all tasks</li> <li>Performance output for each individual task</li> <li>Supporting analyse tasks for static code analysis based on Powershell AST</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Simply define a tasks.ps1 with following content:</p> <pre><code>Register-Task -Name \"Hello world!\" {\n    Write-Host 'hello world!'\n}\n</code></pre> <p>When executing <code>Invoke-Tasks</code> the result looks like following (OS and Powershell version depend on your system):</p> <pre><code>Invoke-Tasks :: Running on OS Darwin 23.2.0 Darwin Kernel Version 23.2.0: Wed Nov 15 21:53:18 PST 2023; root:xnu-10002.61.3~2/RELEASE_ARM64_T6000\u201a\nInvoke-Tasks :: Running with Powershell in version 7.4.1\nInvoke-Tasks ::   ... task data {}\nInvoke-Tasks ::   ... 1 tasks found in \n\nName DependsOn Skip  Parameters\n---- --------- ----  ----------\nDemo           False \n\nInvoke-Tasks :: Running task 'Demo'\nhello world!\nInvoke-Tasks ::  ... took 0,0088361 seconds!\n</code></pre>"},{"location":"analyse-task-registration/","title":"Analyse Task Registration","text":""},{"location":"analyse-task-registration/#why","title":"Why?","text":"<p>Short: I'm not happy with writing custom rules for the PSSCriptAnalyzer.</p>"},{"location":"analyse-task-registration/#how-it-works","title":"How it works","text":"<p>The <code>Invoke-Tasks</code> tool provides two functions:</p> <ul> <li><code>Register-AnalyseTask</code></li> <li><code>Initialize-AnalyseTask</code></li> </ul> <p>The first one allows you to define a analyse function and the second one allows you to define one configuration function to change the defaults.</p> <p>Most optimal you would place a <code>Register-AnalyseTask</code> into a library file. The <code>Initialize-AnalyseTask</code> has to be in a task file.</p> <p>Basically an analyse task provides a function that is capable to traverse the Powershell AST for each defined file. As a result you might get a list of informations, warnings or errors with following structure:</p> <pre><code>$results += [PSCustomObject] @{\n    Type = $nameOfAnalyseFunction\n    File = $PathAndFileName\n    Line = $startLineWhereTheProblemHasBeenFound\n    Column = $startColumnWhereTheProblemHasBeenFound\n    Message = $messageWhatTheProblemExactlyIs\n    Severity = $severityOfTheProblem\n    Code = $optionalCodeFragmentWhereTheProblemHasBeenFound\n}\n</code></pre>"},{"location":"analyse-task-registration/#registration-of-an-analyse-task","title":"Registration of an analyse task","text":""},{"location":"analyse-task-registration/#basic-usage-by-example","title":"Basic usage (by example)","text":"<p>Best explained by given example which is checking the line length. The parameters are always those three:</p> <ul> <li><code>$TaskData</code> to read configuration details (see <code>$TaskData.analyseConfiguration</code>) and to write the results (see <code>$TaskData.analyseResults</code>)</li> <li><code>$PathAndFileName</code> the script that should be analyzed</li> <li><code>$ScriptBlockAst</code> the Powershell AST for the script</li> </ul> <p>The names of the parameters are not required to match but the order is important. The AST is passed since an AST read one time will be used by several analyse tasks.</p> <pre><code>Register-AnalyseTask -Name \"AnalyzeLineLength\" {\n    param(\n        [hashtable] $TaskData,\n        [String] $PathAndFileName,\n        [System.Management.Automation.Language.ScriptBlockAst] $ScriptBlockAst\n    )\n    # get configuration or set default\n    $maximumLineLength = if ($TaskData.analyseConfiguration.AnalyzeLineLength) {\n        $TaskData.analyseConfiguration.AnalyzeLineLength.MaximumLineLength\n    } else {\n        100\n    }\n    $predicate = {$args[0] -is [System.Management.Automation.Language.StatementAst]}\n    $results = $ScriptBlockAst.FindAll($predicate, $true) | ForEach-Object {\n        if ($_.Extent.EndColumnNumber -gt $maximumLineLength) {\n            [PSCustomObject] @{\n                Type = 'AnalyzeLineLength'\n                File = $PathAndFileName\n                Line = $_.Extent.StartLineNumber\n                Column = $_.Extent.StartColumnNumber\n                Message = \"Line too long (exceeds {0})\" -f $maximumLineLength\n                Severity = 'information'\n                Code = $_.Extent.Text\n            }\n        }\n    }\n\n    # for each line number take first reported problem only\n    $results = $results | Group-Object Line | ForEach-Object {\n        $_.Group | Select-Object -First 1\n    }\n\n    $TaskData.analyseResults += $results\n}\n</code></pre> <p>When using this it could look like following (temporarily changed the default to 90):</p> <pre><code>Type              File               Line Column Message                    Severity    Code\n----              ----               ---- ------ -------                    --------    ----\nAnalyzeLineLength ./Invoke-Tasks.ps1  294     13 Line too long (exceeds 90) information $capturedDetails += [PSCustomObject] @{$name = $found.Matches.Groups[1].Value}\nAnalyzeLineLength ./Invoke-Tasks.ps1  441      9 Line too long (exceeds 90) information Write-Message (\"Running with Powershell in version {0}\" -f $PSVersionTable.PSVersio\u2026\nAnalyzeLineLength ./Invoke-Tasks.ps1  457     17 Line too long (exceeds 90) information $fileNames = $TaskData.analyseConfiguration.Global.AnalyzePathAndFileNames\nAnalyzeLineLength ./Invoke-Tasks.ps1  506      9 Line too long (exceeds 90) information $allowedFunctions = @(\"Register-Task\", 'Initialize-AnalyseTask', 'Register-AnalyseT\u2026\nAnalyzeLineLength ./Invoke-Tasks.ps1  560     21 Line too long (exceeds 90) information throw \"line {0}: {1} allowed only\" `\u2026\nAnalyzeLineLength ./Invoke-Tasks.ps1  561     65 Line too long (exceeds 90) information $AllowedFunctions -Join \" and \"\n</code></pre>"},{"location":"analyse-task-registration/#the-initialize-task","title":"The initialize task","text":"<p>Enable of analyse tasks is done by providing a call to <code>Initialize-AnalyseTask</code>; you can define one only.</p> <p>It's important to provide a list of files, otherwise no analyse will be done. For each file the AST is read and passed to each analyse task. If you don't specify your own settings for analyse tasks the defaults are used as documented in Static code analysis.</p> <pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n\n    $files = @('./Invoke-Tasks.ps1')\n    $files += Get-ChildItem -Path './library' -Filter *.ps1\n    $files += Get-ChildItem -Path './tests' -Filter *.ps1\n\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = $files\n        }\n        # other settings\n    }\n}\n</code></pre>"},{"location":"command-line-details/","title":"Command line details","text":""},{"location":"command-line-details/#get-help-details","title":"Get-Help Details","text":"<pre><code>NAME\n    Invoke-Tasks\n\nSYNOPSIS\n    Running Powershell tasks in order (default)\n\n\nSYNTAX\n    Invoke-Tasks [[-TaskFile] &lt;String&gt;] [[-TaskData] &lt;Hashtable&gt;] [[-Tags] &lt;String[]&gt;] [[-CaptureRegexes] \n    &lt;String[]&gt;] [[-TaskLibraryPath] &lt;String&gt;] [-Quiet] [&lt;CommonParameters&gt;]\n\n\nDESCRIPTION\n    Running tasks in order of appearence but also recognize dependencies\n    to ensure that those tasks run first. If you throw an exception\n    the task processing is stopped with the error printed you have\n    choosen.\n\n\nPARAMETERS\n    -TaskFile &lt;String&gt;\n        The default is tasks.ps1 in current folder but you also can\n        define another path and filename.\n\n    -TaskData &lt;Hashtable&gt;\n        Possibility to give parameters to the tasks (default is empty hashtable)\n        The data can be modified by the tasks\n\n    -Tags &lt;String[]&gt;\n        When specifying you can filter for tasks, all others will be adjusted to\n        completed without being executed then.\n\n    -CaptureRegexes &lt;String[]&gt;\n        List of regexes in the format name=&lt;regex&gt;\n        Matching text in task outputs will be written to a 'captured.json' after processing.\n\n    -TaskLibraryPath &lt;String&gt;\n        Path with a Powershell script that does provide reusable tasks.\n        Can also be a folder with scripts.\n\n    -Quiet [&lt;SwitchParameter&gt;]\n        Hide all output except errors and task output itself\n\n    &lt;CommonParameters&gt;\n        This cmdlet supports the common parameters: Verbose, Debug,\n        ErrorAction, ErrorVariable, WarningAction, WarningVariable,\n        OutBuffer, PipelineVariable, and OutVariable. For more information, see\n        about_CommonParameters (https://go.microsoft.com/fwlink/?LinkID=113216). \n\nREMARKS\n    To see the examples, type: \"Get-Help Invoke-Tasks -Examples\"\n    For more information, type: \"Get-Help Invoke-Tasks -Detailed\"\n    For technical information, type: \"Get-Help Invoke-Tasks -Full\"\n</code></pre>"},{"location":"command-line-details/#quiet","title":"Quiet","text":"<p>You can specify <code>-Quiet</code> when using <code>Invoke-Tasks</code> then you see errors and the output of the tasks itself only.</p>"},{"location":"command-line-details/#tags","title":"Tags","text":"<p>You can specify multiple tags at each task. When specifying one of those tags with <code>Invoke-Tasks</code> only those tasks are executed that do match.</p> <pre><code>Register-Task -Name \"First Task\" -Tags first {\n    Write-Host \"First Task\"\n}\n\nRegister-Task -Name \"Second Task\" -Tags second {\n    Write-Host \"Second Task\"\n}\n</code></pre> <p>With <code>Invoke-Tasks -Tags second</code> second task will be processed only.</p> <p>Please note: If you have specified a matching task with a task as dependency that don't match then those task is executed too because a dependency has higher priority.</p>"},{"location":"command-line-details/#capturing-via-regex","title":"Capturing via regex","text":"<p>Main reason for introducing this was to capture information required for the build process. In concrete scenario I intended to get the code coverage percentage for a badge. When your tasks output does print somewhere <code>Covered 96,67%</code> you can execute all with:</p> <pre><code>Invoke-Tasks -CaptureRegexes \"coverage=Covered (\\d+)\" \n</code></pre> <p>A <code>captured.json</code> does look then like following:</p> <pre><code>{\n  \"coverage\": \"96\"\n}\n</code></pre> <p>With following command you simply get the value in your build process:</p> <pre><code>pwsh -Command \"$(Get-Content captured.json|ConvertFrom-JSON).coverage\"\n</code></pre>"},{"location":"command-line-details/#library-tasks","title":"Library Tasks","text":"<p>It's possible to reuse tasks keeping those task in a library file. The library file has same syntax using the <code>Register-Task</code> mechanism.</p> <p>Example for library:</p> <pre><code>Register-Task -Name \"Say Message\" {\n    param ([hashtable] $TaskData)\n    Write-Message $TaskData.Parameters.Message\n}\n</code></pre> <p>Configuration on commandline:</p> <pre><code>Invoke-Tasks -TaskLibraryFile ./task-library.ps1\n</code></pre> <p>Using this task you can do it like following:</p> <pre><code>Use-Task -Name \"My Say Message 1\" -LibraryTaskName \"SayMessage\" {\n    param ([hashtable] $TaskData)\n    $TaskData.Parameters.Message = \"hello world!\"\n}\n</code></pre> <p>It's a contract that <code>$TaskData.Parameters</code> is required to be configured as the library task has defined. In this scenarion the field <code>Message</code> is used. The process is simply that the codeblock of the <code>Use-Task</code> is executed first and then the depedencies (reverse order). Currently it is not implemented to use tags and dependencies on <code>Use-Task</code></p>"},{"location":"static-code-analysis/","title":"Static code analysis","text":""},{"location":"static-code-analysis/#overview","title":"Overview","text":""},{"location":"static-code-analysis/#checking-for-line-length","title":"Checking for line length","text":"<p>The default is 100. You can change it like following:</p> <p><pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        AnalyzeLineLength = @{\n            MaximumLength = 80\n        }\n        # other settings\n    }\n}\n</code></pre> The severity is <code>information</code>.</p>"},{"location":"static-code-analysis/#checking-for-count-of-functions","title":"Checking for count of functions","text":"<p>The default is 20. You can change it like following:</p> <p><pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        AnalyzeFunctionCount = @{\n            MaximumCount = 30\n        }\n        # other settings\n    }\n}\n</code></pre> The severity is <code>information</code>.</p>"},{"location":"static-code-analysis/#checking-for-line-count","title":"Checking for line count","text":"<p>The default is 1000. You can change it like following:</p> <p><pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        AnalyzeLineCount = @{\n            MaximumCount = 500\n        }\n        # other settings\n    }\n}\n</code></pre> The severity is <code>information</code>.</p>"},{"location":"static-code-analysis/#checking-for-function-line-count","title":"Checking for function line count","text":"<p>The default is 50. You can change it like following:</p> <p><pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        AnalyzeFunctionLineCount = @{\n            MaximumCount = 45\n        }\n        # other settings\n    }\n}\n</code></pre> The severity is <code>warning</code>.</p>"},{"location":"static-code-analysis/#checking-for-function-parameter-count","title":"Checking for function parameter count","text":"<p>The default is 5. You can change it like following:</p> <p><pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        AnalyzeFunctionParameterCount = @{\n            MaximumCount = 2\n        }\n        # other settings\n    }\n}\n</code></pre> The severity is <code>warning</code>.</p>"},{"location":"static-code-analysis/#checking-for-function-name","title":"Checking for function name","text":"<p>The name should be always like this:</p> <ul> <li>Using a known verb before the dash like <code>Initialize</code> (see Get-Verb)</li> <li>The name in CamelCase after the dash like <code>AnalyseTask</code> </li> </ul> <p>You cannot change the verb checking. But you can Change the regex for the name after the dash like this (showing the default here):</p> <pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        AnalyzeFunctionName = @{\n            FunctionNameRegex = \"^[A-Z][a-z]+([A-Z][a-z]+)*$\"\n        }\n        # other settings\n    }\n}\n</code></pre> <p>The severity is <code>warning</code>.</p>"},{"location":"static-code-analysis/#checking-for-script-block-line-count","title":"Checking for script block line count","text":"<p>The default is 50. You can change it like following:</p> <p><pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        AnalyzeScriptBlockLineCount = @{\n            MaximumCount = 45\n        }\n        # other settings\n    }\n}\n</code></pre> The severity is <code>warning</code>.</p> <p>Please note: The limit includes also functions since a function does have a script block too. The main focus of course a script block that are not function (eventually I can filter out those ones later one)</p>"},{"location":"static-code-analysis/#checking-for-function-comloc-ratio","title":"Checking for function COM/LOC ratio","text":"<p>The default is 0.25. You can change it like following:</p> <p><pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        AnalyzeFunctionComLocRatio = @{\n            Ratio = 0.5\n        }\n        # other settings\n    }\n}\n</code></pre> The severity is <code>warning</code>. A ratio of 0.25 means 1/4 means one line comment (at least) and three lines of code to keep the ratio. As an example:</p> <pre><code>function Write-Message() {\n    param([String] $Message)\n    # write information message to console\n    Write-Information \"Invoke-Tasks :: $Message\" -InformationAction Continue\n}\n</code></pre> <p>This function will generate following warning message when the ratio would be adjusted to 0.5: <pre><code>Too less comments 'Write-Message' (1/3=0,33 is below 0,5)\n</code></pre></p>"},{"location":"static-code-analysis/#checking-for-function-unused-parameter","title":"Checking for function unused parameter","text":"<p>There is nothing you can adjust. When a parameter (in a param Block) does exist but is not used it will be reported. The severity is <code>warning</code>.</p>"},{"location":"static-code-analysis/#checking-for-trailing-whitepaces","title":"Checking for trailing whitepaces","text":"<p>There is nothing you can adjust. When there are trailing whitespaces it will be reported. The severity is <code>information</code>.</p>"},{"location":"static-code-analysis/#checking-for-function-documentation","title":"Checking for function documentation","text":"<p>There is nothing you can adjust. The analyse does report:</p> <ul> <li>missing synopsis (at least this should be provided)</li> <li>missing parameter documentation</li> <li>documented parameter that is not in the parameter block</li> </ul> <p>The severity is <code>warning</code>.</p>"},{"location":"static-code-analysis/#checking-for-magic-values","title":"Checking for magic values","text":"<p>The default is shown in the given example. You can change it like following:</p> <pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        AnalyzeMagicValues = @{\n            Excludes = @(0, 1, \"`\"`\"\", \"`\"{0}`\"\")\n        }\n        # other settings\n    }\n}\n</code></pre> <p>The severity is <code>warning</code>.</p>"},{"location":"static-code-analysis/#checking-for-function-nested-depth","title":"Checking for function nested depth","text":"<p>The default is 3. You can change it like following:</p> <pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        AnalyzeFunctionNestedDepth = @{\n            MaximumDepth = 4\n        }\n        # other settings\n    }\n}\n</code></pre> <p>The severity is <code>warning</code>.</p>"},{"location":"static-code-analysis/#checking-for-function-return-count","title":"Checking for function return count","text":"<p>The default is 1. You can change it like following:</p> <pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        AnalyzeFunctionReturnCount = @{\n            MaximumCount = 3\n        }\n        # other settings\n    }\n}\n</code></pre> <p>The severity is <code>warning</code>.</p>"},{"location":"static-code-analysis/#checking-for-function-cyclomatic-complexity","title":"Checking for function cyclomatic complexity","text":"<p>The default is 10. You can change it like following:</p> <pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        AnalyzeFunctionCyclomaticComplexity = @{\n            MaximumXomplexity = 5\n        }\n        # other settings\n    }\n}\n</code></pre> <p>The severity is <code>warning</code>.</p> <p>It does count <code>if</code>, <code>elseif</code>, <code>while</code> (with condition to enter loop), <code>for</code> (with condition), <code>switch</code> (cases with a break), <code>trap</code> statements and logical operators (and, or, xor). Each of them count one.</p>"},{"location":"static-code-analysis/#checking-for-script-block-cyclomatic-complexity","title":"Checking for script block cyclomatic complexity","text":"<p>The default is 10. You can change it like following:</p> <pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        AnalyzeScriptBlockCyclomaticComplexity = @{\n            MaximumXomplexity = 5\n        }\n        # other settings\n    }\n}\n</code></pre> <p>The severity is <code>warning</code>.</p> <p>It does count <code>if</code>, <code>elseif</code>, <code>while</code> (with condition to enter loop), <code>for</code> (with condition), <code>switch</code> (cases with a break), <code>trap</code> statements and logical operators (and, or, xor). Each of them count one.</p>"},{"location":"static-code-analysis/#checking-for-script-block-comloc-ratio","title":"Checking for script block COM/LOC ratio","text":"<p>The default ratio is 0.25 and default minimum lines are 3. You can change it like following:</p> <p><pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        AnalyzeScriptBlockComLocRatio = @{\n            Ratio = 0.5\n            MinimumLines = 5\n        }\n        # other settings\n    }\n}\n</code></pre> The severity is <code>warning</code>. The behavior is pretty the same as for the function (see example there)</p>"},{"location":"static-code-analysis/#checking-for-empty-script-blocks","title":"Checking for empty script blocks","text":"<p>There is nothing you can adjust. When there is an empty script block it will be reported. The severity is <code>warning</code>.</p>"},{"location":"task-registration/","title":"Task Registration","text":""},{"location":"task-registration/#how-it-works","title":"How it works","text":"<p>The <code>Invoke-Tasks</code> tool provides two functions:</p> <ul> <li><code>Register-Task</code></li> <li><code>Use-Task</code></li> </ul> <p>The first on allows you to define a task and the second one basically also allows you to define task code but here the scope is to reuse a predefined task.</p>"},{"location":"task-registration/#registering-a-task","title":"Registering a task","text":""},{"location":"task-registration/#basic-usage","title":"Basic usage","text":"<p>At the beginning we have a name and a scriptblock. The name has to be unique.  The scriptblock can be any Powershell code. It's advisible to keep such tasks short and understandable. The example is using the script analyzer tool (see https://github.com/PowerShell/PSScriptAnalyzer) to analyze a file. If any record has been found (independent of its severity) then an exception will be thrown which would stop the task processing. It's on you to do the same or - as an example - to continue processing when there are records with severity 'information' only.</p> <pre><code>Register-Task -Name \"Static code analysis\" {\n    $results = Invoke-ScriptAnalyzer ./Invoke-Tasks.ps1\n    $results | Format-Table\n    if ($results.Count -gt 0) {\n        throw \"ScriptAnalyzer has found issues!\"\n    }\n}\n</code></pre> <p>You're not allowed to write other code than calling <code>Register-Task</code> (and <code>Use-Task</code>), so the only code can be in those script blocks. This is by intention.</p>"},{"location":"task-registration/#dependency","title":"Dependency","text":"<p>Each task can have exactly one idea. Reason for this is that <code>Invoke-Tasks</code> does execute all tasks in a defined order and one task at a time only. You can write a task codeblock that does parallel logic as you like but tasks do not. The next example demonstrates how to use it:</p> <pre><code>Register-Task -Name \"Message1\" -DependOn \"Message2\" {\n    Write-Host \"hello world 1!\"\n}\n\nRegister-Task -Name \"Message2\"  {\n    Write-Host \"hello world 2!\"\n}\n</code></pre> <p>No suprise that second message will be printed before the first message. The <code>Invoke-Tasks</code> does check for cyclic dependencies; if you define that those two task depend on each other the tool will stop with an error before any task has been executed.</p>"},{"location":"task-registration/#tags","title":"Tags","text":"<p>You can specify multiple tags at each task with a comma seperated. When call <code>Invoke-Tags</code> with <code>-Tags</code> the tasks are filtered.</p> <pre><code>Register-Task -Name \"Message1\" -Tags first {\n    Write-Host \"hello world 1!\"\n}\n\nRegister-Task -Name \"Message2\" -Tags second  {\n    Write-Host \"hello world 2!\"\n}\n</code></pre> <p>However following important notes:</p> <ul> <li>if you specify more than one tag in <code>-Tags</code> then a task have to contain all those tags otherwise the task won't be executed</li> <li>if a task does match depending on another task the dependency will be executed even its tags do not match.</li> </ul>"},{"location":"task-registration/#skip","title":"Skip","text":"<p>You can add <code>-Skip</code> to a task and then it is not execute. However if an executable task depend on such a task that dependency will be executed.</p>"},{"location":"task-registration/#tasks-with-dependencies","title":"Tasks with dependencies","text":"<p>For each task you can specify exactly one dependency by using the name of the related task. With this you can change the order of the task execution.</p> <pre><code>Register-Task -Name \"First Task\" -DependsOn \"Second Task\" {\n    Write-Host \"First Task\"\n}\n\nRegister-Task -Name \"Second Task\" {\n    Write-Host \"Second Task\"\n}\n</code></pre> <p>In this case the output of the second task appears before the output of the first task.</p>"},{"location":"useful-links/","title":"Useful links","text":"<ul> <li>https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-powershell</li> <li>https://github.com/marketplace/actions/dynamic-badges</li> <li>https://pester.dev/docs/commands/New-PesterConfiguration</li> </ul>"},{"location":"writing-analyse-tasks/","title":"Writing analyse tasks","text":""},{"location":"writing-analyse-tasks/#parsing-ast","title":"Parsing AST","text":"<p>Parsing of a powershell AST can be done like following:</p> <pre><code>$content = Get-Content Invoke-Tasks.ps1 -Raw\n$scriptBlockAst = [System.Management.Automation.Language.Parser]::ParseInput($content, [ref]$null, [ref]$null)\n</code></pre> <p>With this you get a ScriptBlockAst which is the root ast node for a complete script. This is used in <code>Invoke-Tasks.ps1</code> (as an example)</p> <p>After this you usally will have to filter for AST nodes you are interested in.  Filtering for functions would look like following:</p> <pre><code>$predicate = {$args[0] -is [System.Management.Automation.Language.FunctionDefinitionAst]}\n$functions = $ScriptBlockAst.FindAll($predicate, $true)\n$functions |\u00a0ForEach-Object {\n    $function = $_\n    # do something\n}\n</code></pre>"},{"location":"writing-analyse-tasks/#parsing-tokens","title":"Parsing tokens","text":"<p>In some situations you cannot work with AST only. As an example the comments (<code># some comment</code>) inside a script you won't find in the AST. Therefor you have to explizit parse the tokens like following:</p> <pre><code>$tokens = @()\n[System.Management.Automation.Language.Parser]::ParseInput(`\n    $scriptBlockAst.Extent.Text, [ref]$tokens, [ref]$null) | Out-Null\n\nforeach ($token in $tokens) {\n    # do something\n}\n</code></pre> <p>Of course you can use both but in the example the focus was to have the tokens only. This is used in <code>Measure-FunctionComLocRatio.ps1</code> (as an example).</p> <p>Using <code>$token.Kind</code> is then the way to go.</p> <pre><code>if ($token.Kind -eq [System.Management.Automation.Language.TokenKind]::Comment) {\n    # do something\n}\n</code></pre>"},{"location":"writing-analyse-tasks/#the-analyse-task-registration","title":"The analyse task registration","text":"<p>It's best explained by a given example:</p> <pre><code>Register-AnalyseTask -Name \"AnalyzeFunctionLineCount\" {\n    param(\n        [hashtable] $TaskData,\n        [String] $PathAndFileName,\n        [System.Management.Automation.Language.ScriptBlockAst] $ScriptBlockAst\n    )\n    # get configuration\n    $maximumCount = if ($TaskData.analyseConfiguration.AnalyzeFunctionLineCount) {\n        $TaskData.analyseConfiguration.AnalyzeFunctionLineCount.MaximumCount\n    } else {\n        50\n    }\n    $predicate = {$args[0] -is [System.Management.Automation.Language.FunctionDefinitionAst]}\n    $functions = $ScriptBlockAst.FindAll($predicate, $true)\n\n    $functions | ForEach-Object {\n        $function = $_\n\n        $lineCount = $function.Extent.EndLineNumber - $function.Extent.StartLineNumber\n\n        if ($lineCount -gt $maximumCount) {\n            $TaskData.analyseResults += [PSCustomObject] @{\n                Type = 'AnalyzeFunctionLineCount'\n                File = $PathAndFileName\n                Line = $function.Extent.StartLineNumber\n                Column = $function.Extent.StartColumnNumber\n                Message = \"Too many lines in function '{0}' ({1} exceeds {2})\" `\n                    -f $function.Name, $lineCount, $maximumCount\n                Severity = 'warning'\n                Code = \"\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"writing-analyse-tasks/#using-taskdata","title":"Using $TaskData","text":"<p>The Parameter <code>$TaskData</code> is used to share input and output across multiple tasks executions indepent of the kind of task. It's a (advisible) convention to use certain attributes of this Hastable as documented:</p> <ul> <li><code>$TaskData.analyseConfiguration</code>: it's the Hashtable for all configurations for the analyse tasks.    The concrete configuration in the example is <code>$TaskData.analyseConfiguration.AnalyzeFunctionLineCount</code>    which is documented in Static code analysis.</li> <li><code>$TaskData.analyseResults</code>: it's a list of reported issued. Each issue should be a hashtable with the attributes Type,    File, Line, Column, Message, Severity and Code.</li> </ul>"}]}