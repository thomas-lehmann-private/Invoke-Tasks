{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Invoke-Tasks Documentation","text":"<p>Welcome to the documentation of the <code>Invoke-Tasks</code> tool. Please check the user guide on the left side for details or search for a topic.</p> <p>Here's   the feature list:</p> <ul> <li>Pure Powershell with a single script and no module/assembly dependency</li> <li>Running tasks in defined order</li> <li>Each task can have one dependency that runs first</li> <li>Capturing multiple output by defining named regexes written into a <code>captured.json</code></li> <li>Tasks can be tagged allowing to filter for tasks</li> <li>Tasks can be skipped</li> <li>It's possible to define task libraries (file as well as folder)</li> <li>Scripts are checked to use API functions only.</li> <li>Invoke-Tasks output can be hidden</li> <li>Task data (hashtable) can be shared accross all tasks</li> <li>Performance output for each individual task</li> </ul>"},{"location":"analyse-task-registration/","title":"Analyse Task Registration","text":""},{"location":"analyse-task-registration/#why","title":"Why?","text":"<p>While writing AST functions can be challenging (but solvable) writing PSScriptAnalyzer rules didn't work for me. Also I did write the code exactly as defined in documentation (which is well documented) the using of the rules simply fails and I don't know why. That's why I considered to extent the <code>Invoke-Task</code> by a mechanism that is really simple to use and it works. Also in some cases I got false positives which are really annoying and with the static code analysis mechanism under control I can provide a mechanism that is more easier to handle (future updates).</p>"},{"location":"analyse-task-registration/#how-it-works","title":"How it works","text":"<p>The <code>Invoke-Tasks</code> tool provides two functions:</p> <ul> <li><code>Register-AnalyseTask</code></li> <li><code>Initialize-AnalyseTask</code></li> </ul> <p>The first one allows you to define a analyse function and the second one allows you to define one configuration function to change the defaults.</p> <p>Most optimal you would place a <code>Register-AnalyseTask</code> into a library file. The <code>Initialize-AnalyseTask</code> has to be in a task file.</p> <p>Basically an analyse task provides a function that is capable to traverse the Powershell AST for each defined file. As a result you might get a list of informations, warnings or errors with following structure:</p> <pre><code>$results += [PSCustomObject] @{\n    File = $PathAndFileName\n    Line = $startLineWhereTheProblemHasBeenFound\n    Column = $startColumnWhereTheProblemHasBeenFound\n    Message = $messageWhatTheProblemExactlyIs\n    Severity = $severityOfTheProblem\n    Code = $optionalCodeFragmentWhereTheProblemHasBeenFound\n}\n</code></pre>"},{"location":"analyse-task-registration/#registration-of-an-analyse-task","title":"Registration of an analyse task","text":""},{"location":"analyse-task-registration/#basic-usage-by-example","title":"Basic usage (by example)","text":"<p>Best explained by given example which is checking the line length. The parameters are always those three:</p> <ul> <li><code>$TaskData</code> to read configuration details (see <code>$TaskData.analyseConfiguration</code>) and to write the results (see <code>$TaskData.analyseResults</code>)</li> <li><code>$PathAndFileName</code> the script that should be analyzed</li> <li><code>$ScriptBlockAst</code> the Powershell AST for the script</li> </ul> <p>The names of the parameters are not required to match but the order is important. The AST is passed since an AST read one time will be used by several analyse tasks.</p> <pre><code>Register-AnalyseTask -Name \"Analyze Line Length\" {\n    param(\n        [hashtable] $TaskData,\n        [String] $PathAndFileName,\n        [System.Management.Automation.Language.ScriptBlockAst] $ScriptBlockAst\n    )\n    # get configuration or set default\n    $maximumLineLength = if ($TaskData.analyseConfiguration.'Analyze Line Length') {\n        $TaskData.analyseConfiguration.'Analyze Line Length'.MaximumLineLength\n    } else {\n        100\n    }\n    $predicate = {$args[0] -is [System.Management.Automation.Language.StatementAst]}\n    $results = $ScriptBlockAst.FindAll($predicate, $true) | ForEach-Object {\n        if ($_.Extent.EndColumnNumber -gt $maximumLineLength) {\n            [PSCustomObject] @{\n                File = $PathAndFileName\n                Line = $_.Extent.StartLineNumber\n                Column = $_.Extent.StartColumnNumber\n                Message = \"Line too long (exceeds {0})\" -f $maximumLineLength\n                Severity = 'information'\n                Code = $_.Extent.Text\n            }\n        }\n    }\n\n    # for each line number take first reported problem only\n    $results = $results | Group-Object Line | ForEach-Object {\n        $_.Group | Select-Object -First 1\n    }\n\n    $TaskData.analyseResults += $results\n}\n</code></pre> <p>When using this it could look like following (temporarily changed the default to 90):</p> <pre><code>File               Line Column Message                    Severity    Code\n----               ---- ------ -------                    --------    ----\n./Invoke-Tasks.ps1  294     13 Line too long (exceeds 90) information $capturedDetails += [PSCustomObject] @{$name = $found.Matches.Groups[1].Value}\n./Invoke-Tasks.ps1  441      9 Line too long (exceeds 90) information Write-Message (\"Running with Powershell in version {0}\" -f $PSVersionTable.PSVersion)\n./Invoke-Tasks.ps1  457     17 Line too long (exceeds 90) information $fileNames = $TaskData.analyseConfiguration.Global.AnalyzePathAndFileNames\n./Invoke-Tasks.ps1  506      9 Line too long (exceeds 90) information $allowedFunctions = @(\"Register-Task\", 'Initialize-AnalyseTask', 'Register-AnalyseTask')\n./Invoke-Tasks.ps1  560     21 Line too long (exceeds 90) information throw \"line {0}: {1} allowed only\" `\u2026\n./Invoke-Tasks.ps1  561     65 Line too long (exceeds 90) information $AllowedFunctions -Join \" and \"\n</code></pre>"},{"location":"static-code-analysis/","title":"Static code analysis","text":""},{"location":"static-code-analysis/#checking-for-line-length","title":"Checking for line length","text":"<p>The default is 100. You can change it like following:</p> <p><pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        'Analyze Line Length' = @{\n            MaximumLineLength = 80\n        }\n        # other settings\n    }\n}\n</code></pre> The severity is <code>information</code>.</p>"},{"location":"static-code-analysis/#checking-for-count-of-functions","title":"Checking for count of functions","text":"<p>The default is 20. You can change it like following:</p> <p><pre><code>Initialize-AnalyseTask {\n    param ([hashtable] $TaskData)\n    $TaskData.analyseConfiguration = @{\n        Global = @{\n            AnalyzePathAndFileNames = @('./Invoke-Tasks.ps1')\n        }\n        'Analyze Function Count' = @{\n            MaximumFunctionCount = 30\n        }\n        # other settings\n    }\n}\n</code></pre> The severity is <code>information</code>.</p>"},{"location":"task-registration/","title":"Task Registration","text":""},{"location":"task-registration/#how-it-works","title":"How it works","text":"<p>The <code>Invoke-Tasks</code> tool provides two functions:</p> <ul> <li><code>Register-Task</code></li> <li><code>Use-Task</code></li> </ul> <p>The first on allows you to define a task and the second one basically also allows you to define task code but here the scope is to reuse a predefined task.</p>"},{"location":"task-registration/#registering-a-task","title":"Registering a task","text":""},{"location":"task-registration/#basic-usage","title":"Basic usage","text":"<p>At the beginning we have a name and a scriptblock. The name has to be unique.  The scriptblock can be any Powershell code. It's advisible to keep such tasks short and understandable. The example is using the script analyzer tool (see https://github.com/PowerShell/PSScriptAnalyzer) to analyze a file. If any record has been found (independent of its severity) then an exception will be thrown which would stop the task processing. It's on you to do the same or - as an example - to continue processing when there are records with severity 'information' only.</p> <pre><code>Register-Task -Name \"Static code analysis\" {\n    $results = Invoke-ScriptAnalyzer ./Invoke-Tasks.ps1\n    $results | Format-Table\n    if ($results.Count -gt 0) {\n        throw \"ScriptAnalyzer has found issues!\"\n    }\n}\n</code></pre> <p>You're not allowed to write other code than calling <code>Register-Task</code> (and <code>Use-Task</code>), so the only code can be in those script blocks. This is by intention.</p>"},{"location":"task-registration/#dependency","title":"Dependency","text":"<p>Each task can have exactly one idea. Reason for this is that <code>Invoke-Tasks</code> does execute all tasks in a defined order and one task at a time only. You can write a task codeblock that does parallel logic as you like but tasks do not. The next example demonstrates how to use it:</p> <pre><code>Register-Task -Name \"Message1\" -DependOn \"Message2\" {\n    Write-Host \"hello world 1!\"\n}\n\nRegister-Task -Name \"Message2\"  {\n    Write-Host \"hello world 2!\"\n}\n</code></pre> <p>No suprise that second message will be printed before the first message. The <code>Invoke-Tasks</code> does check for cyclic dependencies; if you define that those two task depend on each other the tool will stop with an error before any task has been executed.</p>"},{"location":"task-registration/#tags","title":"Tags","text":"<p>You can specify multiple tags at each task with a comma seperated. When call <code>Invoke-Tags</code> with <code>-Tags</code> the tasks are filtered.</p> <pre><code>Register-Task -Name \"Message1\" -Tags first {\n    Write-Host \"hello world 1!\"\n}\n\nRegister-Task -Name \"Message2\" -Tags second  {\n    Write-Host \"hello world 2!\"\n}\n</code></pre> <p>However following important notes:</p> <ul> <li>if you specify more than one tag in <code>-Tags</code> then a task have to contain all those tags otherwise the task won't be executed</li> <li>if a task does match depending on another task the dependency will be executed even its tags do not match.</li> </ul>"},{"location":"task-registration/#skip","title":"Skip","text":"<p>You can add <code>-Skip</code> to a task and then it is not execute. However if an executable task depend on such a task that dependency will be executed.</p>"}]}